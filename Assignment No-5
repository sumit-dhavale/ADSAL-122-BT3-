// Problem: Activity Selection Problem with K Persons
// Task: Find the maximum number of shops that K persons can visit without overlapping timings.
// Example: S[] = {1, 3, 3, 5, 7}, E[] = {2, 4, 6, 8, 9}, K = 2 → Output = 5

// Strategy Used: Greedy Algorithm

/*
Logic:-
1) This is an extension of the classic Activity Selection problem.
2) Strategy → Greedy approach: Always pick the shop that finishes earliest among the available ones.
3) A person can visit only non-overlapping shops.
4) Steps:
   - Pair each shop with its start and end time.
   - Sort all shops by their end time (ascending order).
   - Maintain an array (size = K) representing the end time of the last shop visited by each person.
   - For each shop (in sorted order):
       → Check if any person is free before the shop’s start time.
       → If yes, assign this shop to that person and update his end time.
       → Otherwise, skip this shop.
5) Finally, count the total number of shops successfully assigned → gives the maximum shops visitable.
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int maxShops(vector<int>& S, vector<int>& E, int K) {
    int N = S.size();
    vector<pair<int, int>> shops;

    // Pair end and start times for sorting
    for (int i = 0; i < N; i++)
        shops.push_back({E[i], S[i]});

    // Sort shops by end time
    sort(shops.begin(), shops.end());

    // Stores end time of last shop visited by each person
    vector<int> personEnd(K, 0);
    int count = 0;

    // Assign shops greedily
    for (auto &shop : shops) {
        int start = shop.second;
        int end = shop.first;

        // Find a person free before this shop starts
        for (int i = 0; i < K; i++) {
            if (personEnd[i] <= start) {
                personEnd[i] = end;
                count++;
                break;
            }
        }
    }
    return count;
}

int main() {
    vector<int> S = {1, 3, 3, 5, 7};
    vector<int> E = {2, 4, 6, 8, 9};
    int K = 2;

    cout << "Maximum number of shops that can be visited: " 
         << maxShops(S, E, K) << endl;

    return 0;
}
